\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[]{multicol}
\usepackage[auth-lg]{authblk}
\usepackage[margin=1.4in]{geometry}
\usepackage[]{graphicx}
\usepackage[]{ctable}
\usepackage[]{natbib}
\usepackage[]{array}
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}

\title{Benchmarking Current RNA Folding Software and Improvements to the Current Regime}

\begin{document}
\author{Jianglin Liu}
\author{Bingxi Li}
\author{Gregory Rehm}
\affil{\normalsize{University of California, Davis}
\{\texttt{jiliu, bxli, grehm\}@ucdavis.edu}}
\maketitle

\begin{abstract}
Finding the secondary structure of RNA is important for understanding how RNA
will interact in a cell. Frequently computational algorithms are used to determine
structure due to difficulties extracting good \textit{in vivo} data of RNA
structures. Many of the algorithms for RNA folding are computationally complex.
In this paper we establish benchmarks for two commonly used RNA folding packages,
mfold, and RNAfold Vienna, and compare them to an improved Four-Russians folding
algorithm. We show ... These results will help software maintainers to understand
the benefit of updating their algorithms. The results will also help guide users
when choosing RNA folding software when looking for the most computationally optimal package.
\end{abstract}
\section{Introduction}
\par RNA is an essential macromolecule used in protein formation and performs other essential functions within the body\cite{turner}. RNA does not stay in single stranded form and instead folds on itself to create the lowest energy conformation possible to ensure thermodynamic stability\cite{herschlag}. When folding, RNA forms a 2D secondary structure\cite{mccaskill} with A matching to U and G to C (figure 1).  Using this data we can find a 3D tertiary structure\cite{mccaskill}.
\begin{figure}[ht!]
  \centering
  \includegraphics[keepaspectratio, scale=0.12]{fold-example.png}
  \caption{Example of an RNA molecule folding}
  \label{fig:RNA Folding}
\end{figure}
\par Our paper focuses on benchmarking 2D secondary structure prediction software
based off the Nussinov dynamic programming algorithm\cite{nussinov} for RNA folding.
This algorithm is $O(n^3)$ time complexity. There have been multiple attempts to
parallelize the Nussinov algorithm\cite{rizk, other-gpu} which have resulted in
large speed increases, however, CPU intensive algorithms only slightly lowered
the bound up until 2010\cite{minor-nussinov-improvement, chan}. In 2010 the
Nussinov bound that was significantly improved by the Frid-Gusfield Four Russians
method which established you could perform the DP method in $O(\frac{n^3}{log(n)})$
time\cite{gusfield}. Later a parallel method of the Four Russians algorithm
presented proof that you can lower this bound to $O(\frac{n^2}{log(n)})$ inside
an NVIDIA CUDA environment\cite{balaji}.
\par There are two major RNA folding software packages, mfold\cite{zuker1989,zuker1981},
and the Vienna RNA Package\cite{vienna}. These both utilize the Nussimov method
to return results of the RNA secondary structure by finding the lowest possible
thermodynamic conformations of the RNA\cite{zuker1981,vienna}. In order to tell
which was faster we performed application level benchmarks\cite{eulogy} to see
which of these two applications could more quickly fold arbitrary length RNA of
the circular and linear variety. The way mfold is written allows linear RNA to
be treated as exceptional variants of circular ones\cite{circular}. RNAfold
Vienna was initially optimized to only handle linear RNA\cite{circular} but
later improvements enabled it to speed the folding of circular ones\cite{circular}.
As a result we also wish to determine what kind of speed difference still exists
between mfold and Vienna when performing analysis on circular RNA.

\par We then performed micro-benchmarks\cite{sysperformance} of the folding
algorithms utilized in mfold and Vienna for both circular and linear RNA, and
then compared that to equivalent benchmarks for the Four Russians and parallel
Four Russians algorithms. The first thing we found when comparing mfold and
Vienna was ... . When we compared mfold and Vienna to the Four Russians algorithms
we found that without a graphics card and parallel processing capabilities a
machine can see speed ups of ... in mfold and ... in Vienna for linear RNA. For
circular RNA speed increases change to ... in mfold and ... in Vienna. With a
graphics card and parallel processing folding clusters can see increases of up
to ... for mfold and ... in Vienna. Circular RNA also sees speed bumps of ... in
mfold and ... in Vienna.
\par These results show us that ... for natively differentiating between mfold
and Vienna. They also help explain that both pieces of software can experience
significant speed increases if they implemented the Frid-Gusfield method. Furthermore
the authors of this paper would recommend both software packages to support GPU
hardware to achieve even greater speed gains when inside a parallel capable
environment.

\section{Methods}
\subsection{Standardizing the Testing Environment}
Benchmarking is renown as a difficult thing to perform effectively\cite{sysperformance,eulogy}.
There are many processes that can be executing on a computer at any one moment
that it is possible that a benchmark can give inaccurate information due to
conflicting processes running in the background\cite{sysperformance}. As a result
we used a machine solely dedicated for benchmarking and no other tasks. We also
standardized on the following specifications for our runs\cite{benchspecs}:
\begin{center}
    \begin{tabular}{P{5.0cm}P{3.5cm}P{3.0cm}}
        \specialrule{.1em}{.05em}{.05em}
        \textbf{Architecture} & \textbf{Operating System} & \textbf{Compiler} \\ \hline
        8 core Intel i7 CPU 4.00 GHz 16G RAM GeForce GTX 960 & Linux 4.2.5-201 Fedora 22 & GCC 5.1.1-4.fc22 \\ \hline
        " & " & gcc-gfortran 5.1.1-4.fc22\\ \hline
        " & " & NVIDIA CUDA version 5.5 \\
        \specialrule{.1em}{.05em}{.05em}
    \end{tabular}
\end{center}
We used the following applications with corresponding versions and requirements in our test runs:
\begin{center}
    \begin{tabular}{ccc}
        \specialrule{.1em}{.05em}{.05em}
        \textbf{Application} & \textbf{Version} & \textbf{Requirements} \\ \hline
        mfold & 3.6 & GCC, Fortran \\ \hline
        RNAfold Vienna  & 2.1.9 & GCC \\ \hline
        Frid-Gusfield Four Russians & N/A & GCC \\ \hline
        Parallel Four Russians & N/A & GCC, NVIDIA CUDA \\
        \specialrule{.1em}{.05em}{.05em}
    \end{tabular}
\end{center}
\par Our testing architecture was laid out where we would SSH into the benchmarking
machine and then execute tests. Test results would then be reported back to the
user's central machine where they could be stored in a database for later analysis
(figure 2). Our testing required no internet connectivity besides the ssh access
required to initiate our testing so all calculations were performed locally. Also
there were no IO operations except for post processing of mfold and Vienna results.
\begin{figure}[ht!]
  \centering
  \includegraphics[keepaspectratio, scale=0.7]{benchmarking-architecture.png}
  \caption{Test Architecture}
  \label{fig:Testing Arch}
\end{figure}

\subsection{Data Inputs}
\par For input data we give inputs of RNA as strings in a file. An example of this
would be the 10 character RNA string AUGCCAUGGA. This same RNA sequence can be
treated as circular by providing parameters to the mfold and RNAfold Vienna
programs that tell it the RNA is circular\cite{mfold-manual, vienna-manual}.
\subsection{Application Benchmarks}
\par The first type of benchmark we perform is the application level benchmark.
An application benchmark is designed to measure the performance of an entire
application and the resources it consumes on an individual machine\cite{jain}.
In our case we wish to evaluate the amount of time that mfold and RNAfold Vienna
take to return RNA secondary structures given different length RNA strands varying
on linear and circular variety. Since a single run of an application may vary in
time even for identical inputs. Because of this we evaluate each input of RNA 30
times and report the mean $\mu$, standard deviation, $\sigma^2$, of the runs
corresponding to each sequence length.

\subsection{Micro-benchmarks}
\par The most basic type of benchmark to perform is the micro-benchmark. The
micro-benchmark is a single piece of code executed many times in serial so that
we can get a profile of its run characteristics\cite{eulogy,sysperformance}.
Once these characteristics are observed we can then make inferences about its
performance and ways that it can be improved. Micro-benchmarks have the downside
of losing generality of performance across the entire application\cite{eulogy, sysperformance}.
A good example of this is if an IO heavy function made many consecutive calls to
the \textit{read} function on the OS while the rest of the application made no
calls to \textit{read} whatsoever. If we tried to generalize this one function to
the rest of the application we would misguidedly attempt to optimize disk IO
across our entire system.
\par We avoid this trap in our paper by benchmarking only parts of the code that
execute the Nussinov algorithm in mfold and the Vienna package. We then report
these results back to our test results database for later analysis. After this we
compare these results to runs of the serial Frid-Gusfield algorithm and parallel
Frid-Gusfield algorithm.

\subsection{Frid-Gusfield Four-Russians Algorithm}
\par The Four-Russians Algorithm \cite{gusfield} is a two-vector algorithm to
improve the above-mentioned Nussinov $O(n^3)$ Algorithm. The Frid and Gusfield
is an $O(\frac{n^3}{\log n})$ algorithm. The Four Russian algorithm achieves
this speed up by understanding that we can make certain optimizations to the
matrix of matching base pairs required by the Nussinov algorithm. Particularly,
the values along a column from bottom to top and along a row from left to right
are monotonically non-decreasing. Consecutive cells differ at most by 1\cite{gusfield}.
As a result we can perform pre-processing of specific operations that the
Nussinov algorithm must compute manually.

\section{Results}

\section{Discussion}
\begin{thebibliography}{56}
\bibitem{gusfield}
Frid Y, Gusfield D.
\textit{A simple, practical and complete O($n^3$)-time
algorithm for RNA folding using the Four-Russians Speedup}.
Algorithms Mol Biol 2010, 5:13

\bibitem{balaji}
Venkatachalam B, Gusfield D.
\textit{Faster algorithms for RNA-folding using the Four-Russians method}.
Algorithms for Molecular Biology20149:5.

\bibitem{nussinov}
Nussinov R, Jacobson A.
\textit{Fast algorithm for predicting the secondary structure of
single-stranded RNA}.
Proc. Nati. Acad. Sci. USA Vol. 77, No. 11, pp. 6309-6313, November 1980.

\bibitem{turner}
Mathews D, Turner D.
\textit{Prediction of RNA secondary structure by free energy
minimization}.
Current Opinion in Structural Biology 2006, 16:270–278.

\bibitem{mccaskill}
McCaskill J.S.
\textit{The Equilibrium Partition Function and Base Pair
Binding Probabilities for RNA Secondary Structure.}
Biopolymers, Vol. 29,1105-1119 (1990)

\bibitem{herschlag}
Herschlag D.
\textit{RNA Chaperones and the RNA Folding Problem}.
Vol. 270, No. 36, Issue of September 8, pp. 20871–20874, 1995

\bibitem{vienna}
Hofacker I. L, Fontana W, Stadler P. F, Bonhoeffer L. S, Tacker M, Schuster P.
\textit{Fast Folding and Comparison of RNA Secondary Structures}.
Monatshefte ftir Chemie 125, 167-188 (1994)

\bibitem{zuker1989}
Zuker M.
\textit{Computer Prediction of RNA Structure}.
Methods in Enzymology, vol. 180.

\bibitem{zuker1981}
Zuker M, Steigler P.
\textit{Optimal computer folding of large RNA sequences using thermodynamics and auxiliary information}.
Nucleic Acids Research vol. 9 Number 11981.

\bibitem{sysperformance}
Gregg B.
\textit{Systems Performance; Enterprise and the Cloud}.
Pearson Education 2014 Upper Saddle River, NJ

\bibitem{benchspecs}
Altun, O.
\textit{Clustering Application Benchmark}.
IISWC.2006.302742

\bibitem{minor-nussinov-improvement}
Akutsu, T.
\textit{Approximation and Exact Algorithms for RNA
Secondary Structure Prediction and Recognition
of Stochastic Context-free Languages}
Journal of Combinatorial Optimization 3, 321–336 (1999)

\bibitem{chan}
Chan TM.
\textit{More Algorithms for All-Pairs Shortest Paths in Weighted
Graphs}.
SIAM J Comput 2010, 39(5):2075-2089

\bibitem{eulogy}
Cantrill B.
\textit{Eulogy for a benchmark}.
The Observation Deck Web. http://dtrace.org/blogs/bmc/2009/02/02/eulogy-for-a-benchmark/.
2009.

\bibitem{rizk}
Rizk G, Lavenier D.
\textit{GPU accelerated Rna folding algorithm}.
Allen, G.; Nabrzyski, J.; Seidel, E.; Albada, G.D. van; Dongarra, J.; Sloot, P.M.A. 9th International Conference on Computational Science, May 2009, Baton Rouge, United States. Springer., 5544, pp.1031, 2009, LNCS. <10.1000.ISBN: 978-3-642-01969-2>. <hal-00425543>

\bibitem{other-gpu}
Chang D, Kimmer C, Ming O.
\textit{Accelerating the Nussinov RNA Folding Algorithm with CUDA/GPU}
Signal Processing and Information Technology (ISSPIT), 2010 IEEE International Symposium on, 15-18 Dec. 2010, pp. 120-125

\bibitem{circular}
Hofacker I, Stadler P.
\textit{Memory efficient folding algorithms for circular RNA secondary structures}.
Bioinformatics (2006) 22 (10): 1172-1176.

\bibitem{mfold-manual}
Zuker M, Matthews D.H, Turner D.H.
\textit{Algorithms and Thermodynamics for RNA
Secondary Structure Prediction:
a Practical Guide}.
The mfold Web Server Web. http://unafold.rna.albany.edu/doc/mfold-manual/mfold-3.0-manual.pdf.gz.

\bibitem{vienna-manual}
Hofacker I, Fontana W, Bonhoeffer S, Stadler P.F, Lorenz R.
\textit{RNAFOLD}.
Theoretical Biochemistry Group Institute for Theoretical Chemistry Web. https://www.tbi.univie.ac.at/RNA/RNAfold.1.html\#heading5

\bibitem{jain}
Jain, R.
\textit{Art of Computer Systems Performance Analysis Techniques For Experimental Design Measurements Simulation And Modeling}.
Wiley Computer Publishing, John Wiley \& Sons, Inc.
ISBN: 0471503363 Pub Date: 05/01/91.

\end{thebibliography}

\end{document}
